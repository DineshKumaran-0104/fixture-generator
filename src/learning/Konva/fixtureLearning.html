<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>Konva Table Relationship Diagram</title>
        <script src="https://unpkg.com/konva@9/konva.min.js"></script>
        <style>
          body { margin: 0; overflow: hidden; background: #f8f8f8; }
          #container { width: 100vw; height: 100vh; cursor: default; }
        </style>
    </head>
    <body>
        <div id="container"></div>
        <script>
            const data = {
            Round1: {
                M1: { team1: {value: 'Team 1'}, team2: {value: 'Team 2'}},
                M2: { team1: {value: 'Team 3'}, team2: {value: 'Team 4'}},
                M3: { team1: {value: 'Team 5'}, team2: {value: 'Team 6'}},
                M4: { team1: {value: 'Team 7'}, team2: {value: 'Team 8'}},
                M5: { team1: {value: 'Team 9'}, team2: {value: 'Team 10'}},
                M6: { team1: {value: 'Team 11'}, team2: {value: 'Team 12'}},
                M7: { team1: {value: 'Team 13'}, team2: {value: 'Team 14'}},
                M8: { team1: {value: 'Team 15'}, team2: {value: 'Team 16'}}
            },
            Round2: {
                M1: { team1: {value: 'Team 1'}, team2: {value: 'Team 3'}},
                M2: { team1: {value: 'Team 6'}, team2: {value: 'Team 7'}},
                M3: { team1: {value: 'Team 9'}, team2: {value: 'Team 12'}},
                M4: { team1: {value: 'Team 14'}, team2: {value: 'Team 15'}}
            },
            Round3:{
                S1: { team1: {value: 'Team 1'}, team2: {value: 'Team 6'}},
                S2: { team1: {value: 'Team 9'}, team2: {value: 'Team 15'}}
            },
            Final: {
                F: { team1: {value:'Team 1'}, team2: {value: 'Team 9'}},
            },
            };


            const stage = new Konva.Stage({
                container: 'container',
                width: window.innerWidth,
                height: window.innerHeight,
                draggable: false
            });

            const layer = new Konva.Layer();
            stage.add(layer);

            // --- DRAW FIXTURE ---
            function drawKnockoutBracket(data) {
                const rounds = Object.keys(data);
                const roundPositions = {};

                const matchBoxWidth = 140;
                const matchBoxHeight = 30;
                const headerHeight = 25;
                const verticalGap = 100;
                const roundGap = 250;
                const roundHeight = 250
                const yOffsetBase = 100;

                // total columns in the entire match like Round1 left, round1 right, final, semi left, semi right...etc
                const totalColumns = getTotalColumns(data);

                //roundName:- Round1, Round2
                rounds.forEach((roundName, roundIndex) => {
                    const matches = Object.entries(data[roundName]);
                    //const roundX = 100 + roundIndex * roundGap;

                    const leftMatches = [];
                    const rightMatches = [];
                    if (roundName.includes("Round")) {
                        const half = matches.length / 2;
                        leftMatches.push(...matches.slice(0, half));
                        rightMatches.push(...matches.slice(half));
                    }

                    const drawMatches = (matchList, side = "center") => {
                        // matchId - M1, M2
                        matchList.forEach(([matchId, matchDetails], i) => {
                            let yBase=0;
                            if(roundIndex === 0){
                                yBase = yOffsetBase + i * (matchBoxHeight * 2 + verticalGap)+ roundIndex*verticalGap;
                            } else {
                                let prevRound = data[rounds[roundIndex-1]];
                                let prevRoundNames = Object.keys(prevRound);
                                let startIndex;
                                if(side === 'left'){
                                    startIndex = i*2;
                                } else {
                                    startIndex = prevRoundNames.length/2+i*2;
                                }
                                let prevMatch1 = prevRound[prevRoundNames[startIndex]];
                                let prevMatch2 = prevRound[prevRoundNames[startIndex+1]];
                                let prevMatch1yBase = prevMatch1.yBase;
                                let prevMatch2yBase = prevMatch2.yBase;
                                yBase = (prevMatch1yBase + prevMatch2yBase)/2;
                            }

                            //find position
                            const xBase =
                            side === "left"
                                ? roundIndex * roundGap
                                : (totalColumns-1 - roundIndex)*roundGap

                            // Create group for the whole match
                            const matchGroup = new Konva.Group({
                                x: xBase,
                                y: yBase,
                                draggable: false,
                            });


                            // Background box (container)
                            const matchBg = new Konva.Rect({
                                width: matchBoxWidth,
                                height: headerHeight + 2 * matchBoxHeight + 10,
                                fill: "#f9f9f9",
                                stroke: "#555",
                                cornerRadius: 6,
                                shadowBlur: 5,
                            });

                            // Header (match name)
                            const headerText = new Konva.Text({
                                x: 0,
                                y: 2,
                                width: matchBoxWidth,
                                text: matchId,
                                align: "center",
                                fontStyle: "bold",
                                fontSize: 14,
                                fill: "#222",
                            });

                            matchGroup.add(matchBg);
                            matchGroup.add(headerText);

                            const teamPositions = [];
                            let yCursor = headerHeight;

                            const contextObject = {};
                            contextObject.matchBoxWidth = matchBoxWidth;
                            contextObject.matchBoxHeight = matchBoxHeight;
                            contextObject.xBase = xBase;
                            contextObject.yBase = yBase;
                            contextObject.yCursor = yCursor;
                            //team1
                            drawTeamBox(matchGroup, matchDetails.team1, teamPositions, contextObject);
                            //team2
                            drawTeamBox(matchGroup, matchDetails.team2, teamPositions, contextObject)

                            layer.add(matchGroup);

                            // Store center/midpoint info for connecting lines
                            if (!roundPositions[roundName]) roundPositions[roundName] = {};
                            const midY = (teamPositions[0].y + teamPositions[1].y) / 2;
                            roundPositions[roundName][matchId] = {
                                pos: side,
                                leftX: xBase,
                                rightX: xBase + matchBoxWidth,
                                midY,
                            };
                            matchDetails.XBase = xBase;
                            matchDetails.yBase = yBase;
                        });
                    };

                    if (roundName.includes("Round")) {
                        drawMatches(leftMatches, "left");
                        drawMatches(rightMatches, "right");
                    } else {
                        drawMatches(matches, "left");
                    }
                });

                // Draw connections between rounds
                const roundsKeys = Object.keys(data);
                for (let i = 0; i < roundsKeys.length - 1; i++) {
                    const currentRound = roundsKeys[i];
                    const nextRound = roundsKeys[i + 1];

                    const currentMatches = Object.keys(data[currentRound]);
                    const nextMatches = Object.keys(data[nextRound]);

                    nextMatches.forEach((nextId, index) => {
                        const nextPos = roundPositions[nextRound][nextId];
                        const from1 = roundPositions[currentRound][currentMatches[index * 2]];
                        const from2 = roundPositions[currentRound][currentMatches[index * 2 + 1]];

                        console.log(roundPositions);

                        if (from1 && from2 && nextPos && from1.pos === "left") {
                            const midX = (from1.rightX + nextPos.rightX) / 2; // midpoint horizontally

                            // Top connector (from first match)
                            const line1 = new Konva.Line({
                            points: [
                                from1.rightX, from1.midY, // from M1
                                from1.rightX + 30, from1.midY, // short horizontal
                                from1.rightX + 30, nextPos.midY, // vertical
                                midX, nextPos.midY, // horizontal to middle of next round
                            ],
                            stroke: "#00aaff",
                            strokeWidth: 2,
                            lineCap: "round",
                            lineJoin: "round",
                            });

                            // Bottom connector (from second match)
                            const line2 = new Konva.Line({
                            points: [
                                from2.rightX, from2.midY,
                                from2.rightX + 30, from2.midY,
                                from2.rightX + 30, nextPos.midY,
                                midX, nextPos.midY,
                            ],
                            stroke: "#00aaff",
                            strokeWidth: 2,
                            lineCap: "round",
                            lineJoin: "round",
                            });

                            // Middle connector to next match
                            const connector = new Konva.Line({
                            points: [
                                midX, nextPos.midY,
                                nextPos.leftX - 10, nextPos.midY,
                            ],
                            stroke: "#00aaff",
                            strokeWidth: 2,
                            lineCap: "round",
                            lineJoin: "round",
                            });

                            layer.add(line1);
                            layer.add(line2);
                            layer.add(connector);
                        } else {
                            const midX = (from1.leftX + nextPos.leftX) / 2; // midpoint horizontally

                            // Top connector (from first match)
                            const line1 = new Konva.Line({
                            points: [
                                from1.leftX, from1.midY, // from M1
                                from1.leftX - 30, from1.midY, // short horizontal
                                from1.leftX - 30, nextPos.midY, // vertical
                                midX, nextPos.midY, // horizontal to middle of next round
                            ],
                            stroke: "#00aaff",
                            strokeWidth: 2,
                            lineCap: "round",
                            lineJoin: "round",
                            });

                            // Bottom connector (from second match)
                            const line2 = new Konva.Line({
                            points: [
                                from2.leftX, from2.midY,
                                from2.leftX - 30, from2.midY,
                                from2.leftX - 30, nextPos.midY,
                                midX, nextPos.midY,
                            ],
                            stroke: "#00aaff",
                            strokeWidth: 2,
                            lineCap: "round",
                            lineJoin: "round",
                            });

                            // Middle connector to next match
                            const connector = new Konva.Line({
                            points: [
                                midX, nextPos.midY,
                                nextPos.rightX+10, nextPos.midY,
                            ],
                            stroke: "#00aaff",
                            strokeWidth: 2,
                            lineCap: "round",
                            lineJoin: "round",
                            });

                            layer.add(line1);
                            layer.add(line2);
                            layer.add(connector);
                        }
                    });

                }

                layer.batchDraw();
            }

            function getTotalColumns(data){
                if(data){
                    let rounds = Object.keys(data);
                    if(rounds.indexOf('Final') !== -1){
                        return (rounds.length - 1) * 2 + 1;
                    }
                    return rounds.length * 2;
                }
                return 0;
            }

            function drawTeamBox(matchGroup, team, teamPositions, contextObject){
                const rect = new Konva.Rect({
                    x: 0,
                    y: contextObject.yCursor,
                    width: contextObject.matchBoxWidth,
                    height: contextObject.matchBoxHeight,
                    fill: "#fff",
                    stroke: "#999",
                });

                const text = new Konva.Text({
                    x: 0,
                    y: contextObject.yCursor + 6,
                    width: contextObject.matchBoxWidth,
                    align: "center",
                    text: team.value,
                    fontSize: 13,
                });

                matchGroup.add(rect);
                matchGroup.add(text);

                teamPositions.push({
                    x: contextObject.xBase + contextObject.matchBoxWidth,
                    y: contextObject.yBase + contextObject.yCursor + contextObject.matchBoxHeight / 2,
                });

                contextObject.yCursor += contextObject.matchBoxHeight;
            }

            drawKnockoutBracket(data);

            // Enable zoom in/out
            stage.on('wheel', (e) => {
            e.evt.preventDefault();
                const oldScale = stage.scaleX();
                const pointer = stage.getPointerPosition();
                const scaleBy = 1.05;
                const direction = e.evt.deltaY > 0 ? -1 : 1;
                const newScale = direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;

                const mousePointTo = {
                    x: (pointer.x - stage.x()) / oldScale,
                    y: (pointer.y - stage.y()) / oldScale,
                };

                stage.scale({ x: newScale, y: newScale });

                const newPos = {
                    x: pointer.x - mousePointTo.x * newScale,
                    y: pointer.y - mousePointTo.y * newScale,
                };
                stage.position(newPos);
                stage.batchDraw();
            });

            // Enable right-click drag (panning)
            let isPanning = false;
            let lastPos = null;

            stage.on('mousedown', (e) => {
            if (e.evt.button === 2) {  // right click
                isPanning = true;
                lastPos = stage.getPointerPosition();
                document.body.style.cursor = 'grabbing';
            }
            });

            stage.on('mouseup', () => {
                isPanning = false;
                document.body.style.cursor = 'default';
            });

            stage.on('mousemove', (e) => {
                if (!isPanning) return;
                const pos = stage.getPointerPosition();
                const dx = pos.x - lastPos.x;
                const dy = pos.y - lastPos.y;

                stage.x(stage.x() + dx);
                stage.y(stage.y() + dy);
                stage.batchDraw();

                lastPos = pos;
            });

            // Disable default context menu
            stage.container().addEventListener('contextmenu', (e) => e.preventDefault());

        </script>
    </body>
</html>